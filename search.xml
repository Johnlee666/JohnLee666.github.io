<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[面试总结]]></title>
      <url>http://lizhan.me/2018/04/15/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="暑假实习面试总结"><a href="#暑假实习面试总结" class="headerlink" title="暑假实习面试总结"></a>暑假实习面试总结</h1><h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><h3 id="一面（电面，3-13）"><a href="#一面（电面，3-13）" class="headerlink" title="一面（电面，3.13）"></a>一面（电面，3.13）</h3><ol>
<li>简述各种排序算法，快排的思想，怎么改进 </li>
<li>GCD</li>
<li>category与继承的区别 category添加属性 关联对象</li>
<li>多模块通信</li>
<li>项目介绍</li>
<li>深度遍历和广度遍历</li>
<li>常用的设计模式</li>
<li><p>智力题 男生&gt;女生 理科&gt;文科 理科男&gt;文科女？</p>
<a id="more"></a>
</li>
</ol>
<h3 id="二面（电面，3-19）"><a href="#二面（电面，3-19）" class="headerlink" title="二面（电面，3.19）"></a>二面（电面，3.19）</h3><ol>
<li>加密算法 对称 非对称 主要是质因数分解</li>
<li>HTTPS握手过程</li>
<li>iOS crash收集的机制 异常捕获 信号 符号表</li>
<li>说一说理解的runtime</li>
<li>用runtime做过什么</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二面完第二天官网就变成已回绝。这次挂了，自己总结一下主要是加密算法和crash没答好，所以之后对自己简历上写的东西一定要负责，写了的东西一定要去深入的了解。</p>
<h2 id="网易有道"><a href="#网易有道" class="headerlink" title="网易有道"></a>网易有道</h2><h3 id="一面（视频面，3-15）"><a href="#一面（视频面，3-15）" class="headerlink" title="一面（视频面，3.15）"></a>一面（视频面，3.15）</h3><ol>
<li>项目介绍</li>
<li>tableview优化 离屏渲染</li>
<li>快速选择算法 快排变 时间复杂度O(n)</li>
<li>autoreleasepool原理 降低内存峰值</li>
<li>多线程使用 GCD NSOperationQueue</li>
<li>属性修饰符（什么时候用copy）</li>
<li>UIWebView WKWebView区别</li>
<li>存储相关 plist Userdefault coreData sqlite FMDB</li>
</ol>
<h3 id="二面（电面，3-15）"><a href="#二面（电面，3-15）" class="headerlink" title="二面（电面，3.15）"></a>二面（电面，3.15）</h3><ol>
<li>早上面完下午就问能不能直接去北京，我说了下学校课还有点多，他就说好的，之后就没消息了，可能是看去不了就不面了吧233</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这次是橙子帮忙内推的，应该是和校招的不是一起，好像是招的日常实习生，非常缺人，需要马上过去。然后之后网易的笔试没有通过，所以还是和网易无缘吧</p>
<h2 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h2><h3 id="一面（视频面，3-19）"><a href="#一面（视频面，3-19）" class="headerlink" title="一面（视频面，3.19）"></a>一面（视频面，3.19）</h3><ol>
<li>OC和C++多态实现原理 虚函数表（动态绑定），动态类型</li>
<li>autorelease用来干什么</li>
<li>block的原理，怎么截获对象的 分配在不同区域的block</li>
<li>GCD NSOperation 使用GCD怎么实现addDependency 实现线程安全的数组</li>
<li>网络。聊天程序：A，B两台机器互相通信的过程</li>
<li>36进制转换算法 和大数算法原理差不多</li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>面了一个多小时，算法也写出来了，但是还是没信了，主要是OC基础还是不扎实，然后有些题目没能理解面试官的意思，导致给的回答可能跟面试官预想中的不一样。然后对于多线程和网络的问题的理解还需要进一步的加深。</p>
<h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><h3 id="一面（电面，3-19）"><a href="#一面（电面，3-19）" class="headerlink" title="一面（电面，3.19）"></a>一面（电面，3.19）</h3><ol>
<li>项目碰到的难点 面试官说看了之前github上的项目，这也是面试这么久第一次有面试官看= =。感觉挺用心的。</li>
<li>runtime</li>
<li>autoreleasepool的底层实现 双向链表+哨兵元素</li>
<li>GCD group+信号量</li>
<li>VC的生命周期 loadView</li>
<li>cell复用机制</li>
<li>如何管理人员</li>
<li>是否看过源码或者开源库</li>
<li>category原理 关联对象添加属性</li>
<li>NSArray和NSSet的实现 hash</li>
<li>RAC MVVM</li>
<li>命名规范</li>
<li>UIRespond和UIControl的区别</li>
<li>怎么给UIView添加点击事件 事件响应链</li>
<li>UIButton添加多个点击事件</li>
</ol>
<h3 id="二面（电面，3-20）"><a href="#二面（电面，3-20）" class="headerlink" title="二面（电面，3.20）"></a>二面（电面，3.20）</h3><ol>
<li>runtime 为什么说OC是动态的语言</li>
<li>怎么快速查找方法 cache是用什么数据结构实现的</li>
<li>数据库索引 实现的数据结构 B/B+树</li>
<li>TCP三次握手 四次挥手 为什么是三次和四次</li>
<li>常见的排序算法 O(n)的算法 即计数 桶排等</li>
<li>说下哈希表 哈希表查找的时间复杂度</li>
<li>了解动态规划吗 递推式  背包问题 和贪心的区别</li>
<li>牛顿迭代法 边界判断 浮点数比较 精度</li>
</ol>
<h3 id="三面（电面，3-31）"><a href="#三面（电面，3-31）" class="headerlink" title="三面（电面，3.31）"></a>三面（电面，3.31）</h3><ol>
<li>二面过后面试官说通过，三面大约在一周后，但是等了一周还是没消息，于是给之前的一面面试官发了短信。面试官人很好，马上帮我找人进行了三面。</li>
<li>三面是交叉面，面试官说之前技术都问过了，聊些其他的东西</li>
<li>学习方法</li>
<li>项目管理</li>
<li>前沿技术</li>
<li>主要是考察沟通能力，技术的广度和热情吧</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>第二天官网状态就变成了拟录取。然后清明前hr就发了口头offer，但是正式offer还是等了很久= =。整个面试过程中感觉面试官都非常好（并不是因为让我过了），遇到不会的问题，会主动提醒你，通过面试还学到了很多知识。拿到offer后整个人感觉不会像之前那么大压力了，不然0offer看到身边的人都已经收割大厂了真的很难受233.</p>
<h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="一面（现场霸面，4-11）"><a href="#一面（现场霸面，4-11）" class="headerlink" title="一面（现场霸面，4.11）"></a>一面（现场霸面，4.11）</h3><ol>
<li>自我介绍，项目介绍</li>
<li>tcp和udp的区别 udp广播路由穿透</li>
<li>tcp重传和拥塞控制 相对往返时间计算</li>
<li>设计模式 修饰模式 画UML类图</li>
<li>HTTPS握手过程 CA证书签名过程</li>
<li>输入url的过程 浏览器渲染</li>
<li>HTTPS如何协商协议版本号</li>
<li>linux服务器知识 sed</li>
<li>虚拟内存 页面置换算法</li>
<li>进程线程的区别</li>
<li>进程间通信方式 共享内存区的实现</li>
<li>编译过程  不同机器交叉编译 多进程地址</li>
<li>内存区管理 栈区存放的变量 函数参数入栈过程 函数中抛出异常后什么怎么处理的</li>
<li>欧拉回路算法</li>
</ol>
<h3 id="新一面（现场面试，4-11-转推部门-SNG-QQ支付）"><a href="#新一面（现场面试，4-11-转推部门-SNG-QQ支付）" class="headerlink" title="新一面（现场面试，4.11 转推部门 SNG QQ支付）"></a>新一面（现场面试，4.11 转推部门 SNG QQ支付）</h3><ol>
<li>TCP三次握手 为什么不是两次 四次</li>
<li>HTTPS握手过程 为什么这样就是安全的 直接用非对称加密不行吗</li>
<li>ARC MRC区别 编译器自动生成代码</li>
<li>UIView 关键帧动画</li>
<li>说说了解的设计模式 工厂模式怎么好了 不是增加耦合吗</li>
<li>GCD NSOperationQueue的区别  分别在什么场景使用 GCD有什么问题</li>
<li>项目介绍 hybrid的难点 用了什么框架</li>
<li>自己有没有封装过比较复杂的控件</li>
<li>检测内存泄露 leaks </li>
<li>dealloc 通知释放</li>
<li>证书签发机制</li>
<li>sb和代码用哪个 区别</li>
<li>启动优化</li>
<li>性能优化卡顿分析 tableview 离屏渲染和手绘圆角的效率问题</li>
<li>手写strcmp算法</li>
</ol>
<h3 id="二面（现场面试，4-12）"><a href="#二面（现场面试，4-12）" class="headerlink" title="二面（现场面试，4.12）"></a>二面（现场面试，4.12）</h3><ol>
<li>自我介绍 项目介绍</li>
<li>项目中用到的一些开源库</li>
<li>项目包大小管理</li>
<li>前沿技术了解</li>
<li>Python是不是单进程的 怎么解决并发 什么是管程</li>
<li>学习方式</li>
<li>weak assign关键字</li>
<li>MRC ARC区别</li>
<li>设计模式 工厂</li>
<li>如何实现网络请求, 一般返回的数据是什么格式, 如何解析.</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>腾讯提前批因为没选事业群所以一直在简历池里泡着。然后笔试做完收到测评又没收到面试通知，好像是因为自己把面试地点写成重庆的原因。腾讯面试是去的成都霸面，腾讯有专门的霸面区，而且接待的hr都很好，早上去签到大约一个小时就收到通知了。进去遇到了整个面试过程中感觉最难也是最基础的一次面试= =，因为是做安卓的面试官，然后就全问的是基础知识，面试的时候感觉基础还是需要加强。最后看到面试官出了欧拉回路整个人都懵了一下= = 但是还好思考了一下还是把大概过程写出来了，面试官也说没什么问题。但整体可能不是很理想，所以面试官就说帮我转推一个做iOS的部门。然后下午就收到了新一轮的面试，面试过程挺轻松，iOS问的都很浅，我甚至认为面试官还不是做iOS的，但最后我问了下，面试官还真是做iOS的。但是感觉沟通起来有点吃力，可能是没get到面试官的点吧。二面总监也没问什么技术问题，没多久就让出来了。这里还有个小插曲，我和小伙伴是面的同一个一面面试官，二面总监甚至是一前一后的。进去后面试官直接问认不认识。。然后等了一天不适合= =。感觉这次挂的莫名其妙的，可能还是和面试官气场不和吧。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS内存管理学习笔记]]></title>
      <url>http://lizhan.me/2018/03/18/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="iOS内存管理"><a href="#iOS内存管理" class="headerlink" title="iOS内存管理"></a>iOS内存管理</h1><h2 id="什么是自动引用计数（ARC）"><a href="#什么是自动引用计数（ARC）" class="headerlink" title="什么是自动引用计数（ARC）"></a>什么是自动引用计数（ARC）</h2><blockquote>
<p>在LLVM编译器中设置ARC为有效状态，就无需再次键入retain或者是release代码</p>
<ul>
<li>使用Xcode4.2或以上版本</li>
<li>使用LLVM编译器3.0或以上版本</li>
<li>编译器选项中设置ARC为有效</li>
<li>引用树根对象(NSApplication/UIApplication)</li>
</ul>
</blockquote>
<h2 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h2><a id="more"></a>
<ol>
<li>自己生成的对象，自己持有<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
<li><strong><em>注意驼峰命名</em></strong></li>
</ul>
</li>
<li>非自己生成的对象，自己也能持有<ul>
<li>array</li>
<li>init返回的对象不会注册到自动释放池中</li>
<li>autorelease</li>
</ul>
</li>
<li>不再需要自己持有的对象时释放<ul>
<li>release之后清空指针（避免悬挂指针的出现）</li>
</ul>
</li>
<li>非自己持有的对象无法释放<ul>
<li>释放非自己持有的对象可能会造成程序崩溃（放回可用内存池）</li>
</ul>
</li>
</ol>
<h2 id="alloc-retain-release-autorelease-dealloc实现"><a href="#alloc-retain-release-autorelease-dealloc实现" class="headerlink" title="alloc/retain/release/autorelease/dealloc实现"></a>alloc/retain/release/autorelease/dealloc实现</h2><h3 id="GNUstep框架"><a href="#GNUstep框架" class="headerlink" title="GNUstep框架"></a><a href="https://github.com/gnustep/libs-base/edit/master/Source/NSObject.m" target="_blank" rel="external">GNUstep框架</a></h3><ul>
<li>GNUstep是Cocoa的互换框架</li>
<li>alloc</li>
<li>allocWithZone</li>
</ul>
<h3 id="苹果的实现"><a href="#苹果的实现" class="headerlink" title="苹果的实现"></a><a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/" target="_blank" rel="external">苹果的实现</a></h3><ul>
<li>散列表</li>
</ul>
<h2 id="ARC下的规则"><a href="#ARC下的规则" class="headerlink" title="ARC下的规则"></a>ARC下的规则</h2><ol>
<li>不能使用alloc/retain/release/autorelease(ARC直接使用C语言函数)</li>
<li>不能使用NSAllocateObject/NSDeallocateObject</li>
<li>须遵守内存管理的方法命名规则</li>
<li>不要显式调用dealloc</li>
<li>使用@autoreleasepool块替代NSAutoreleasePool</li>
<li>不能使用区域（NSZone）</li>
<li>对象型变量不能作为C语言结构体(struct/union)的成员</li>
<li>显示转换id和void*</li>
</ol>
<h2 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h2><ul>
<li>__strong</li>
<li>__weak（保留环）</li>
<li>__unsafe_unretained</li>
<li>__autoreleasing</li>
<li>一般不显式声明</li>
<li>对象作为函数返回值，自动注册到autoreleasepool</li>
<li>在访问附有__weak修饰符的变量时，实际上必定要访问注册到autoreleasepool的对象</li>
<li>id的指针或对象的指针在没有显式指定时会被附加上__autoreleasing修饰符（NSError）</li>
<li>与属性修饰符的关系（保留新值，释放旧值，设置实例变量）</li>
</ul>
<h2 id="不要使用retainCount"><a href="#不要使用retainCount" class="headerlink" title="不要使用retainCount"></a>不要使用retainCount</h2><ul>
<li>考虑autorealease</li>
<li>在保留计数还是1的时候可能就回收了</li>
</ul>
<h2 id="在dealloc方法中只释放引用并解除监听"><a href="#在dealloc方法中只释放引用并解除监听" class="headerlink" title="在dealloc方法中只释放引用并解除监听"></a>在dealloc方法中只释放引用并解除监听</h2><ul>
<li>自动调用析构函数</li>
<li>取消KVO和通知</li>
<li>malloc()分配在堆上的内存和CoreFoundation中的对象</li>
<li>系统未必会在每个对象上调用其dealloc方法</li>
</ul>
<h2 id="使用autoreleasepool降低内存峰值"><a href="#使用autoreleasepool降低内存峰值" class="headerlink" title="使用autoreleasepool降低内存峰值"></a>使用autoreleasepool降低内存峰值</h2><ul>
<li>每次runloop释放自动释放池</li>
<li>自己在循环中创建池</li>
</ul>
<h2 id="ARC的实现"><a href="#ARC的实现" class="headerlink" title="ARC的实现"></a>ARC的实现</h2><ul>
<li>objc_retainAutoReleasedReturnValue</li>
<li>objc_autoreleaseReturnValue</li>
<li>__weak修饰符置nil的实现</li>
</ul>
<ol>
<li>从weak表中获取废弃对象的地址为键值的记录</li>
<li>将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil</li>
<li>从weak表中删除该记录</li>
<li>从引用计数表中删除废弃对象的地址为键值的记录</li>
</ol>
<ul>
<li>不支持__weak修饰符的类(NSMachPort)</li>
<li>allowsWeakReference/retainWeakRefence方法</li>
</ul>
<h2 id="用僵尸对象调试管理内存"><a href="#用僵尸对象调试管理内存" class="headerlink" title="用僵尸对象调试管理内存"></a>用僵尸对象调试管理内存</h2><ul>
<li>对象转化为僵尸对象但不会彻底回收</li>
<li>僵尸类是从名为<em>NSZombie</em>的模板类里复制出来的</li>
<li>系统会修改对象的isa指针，令其指向特殊的僵尸类</li>
</ul>
<h2 id="使用Instruments调试"><a href="#使用Instruments调试" class="headerlink" title="使用Instruments调试"></a>使用Instruments调试</h2><ul>
<li>使用Leak来查看内存泄露</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS中的pt和px]]></title>
      <url>http://lizhan.me/2017/08/09/iOS%E4%B8%AD%E7%9A%84pt%E5%92%8Cpx/</url>
      <content type="html"><![CDATA[<h1 id="iOS关于px和pt的一些问题"><a href="#iOS关于px和pt的一些问题" class="headerlink" title="iOS关于px和pt的一些问题"></a>iOS关于px和pt的一些问题</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近在还原psd设计图的时候遇到一些问题，就是设计图上给的距离都是px而在iOS开发中却可能用到pt这个单位。那这两者的换算关系是什么呢。之前的话直接都是把视觉稿的px除以2当pt来用，也没有深究为什么。这几天想深入了解一下，但是网上资料鱼龙混杂，一些错误的概念充斥其间，所以想写篇文章来好好理一理其中的一些关系。这之前需要先解释几个概念:</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>DPI</p>
<blockquote>
<p>DPI (Dots Per Inch) Dot 指的是采样或输出的最小单位，它很抽象，在不同的设备里会和不同的具体事物关联起来。比如：扫描仪的 Dot 就是它能扫描（采样）出的最小一点色彩信息，这些采样点集合起来然后转换为对应的像素，一般不是一对一的；打印机的 Dot 就是它能印出的最小墨点，需要许多个墨点组合起来才能表现出数字图片中的一个（虚拟的）像素；而有时我们用 DPI 来描述显示器时，Dot 就是显示器的逻辑像素，如iPhone中的pt (point)。</p>
</blockquote>
</li>
<li><p>PPI</p>
<blockquote>
<p>计算机显示设备从打印机中借鉴了DPI的概念，由于计算机显示设备中的原子单位不是墨汁点而是像素，所以就创造了PPI(Pixels Per Inch)，这个值是屏幕每英寸的像素数量，即像素密度(Screen density)。这里的像素一般指的是物理像素(Physical Pixel)。我们一般将屏幕对角线的物理长度与对角线上的像素数的比值作为PPI的近似值。在屏幕尺寸固定的情况下，PPI越高越清晰（如后面所说的retina屏幕）</p>
</blockquote>
</li>
<li><p>px</p>
<blockquote>
<p>px是Pixel的缩写，也就是说像素是指基本原色素及其灰度的基本编码，由 Picture(图像) 和 Element（元素）这两个单词的字母所组成的。我们平时常说的分辨率就是由宽高像素个数相乘得到。但仅凭这一分辨率并不能判断屏幕清晰程度，还要与屏幕尺寸相联系。</p>
</blockquote>
</li>
<li><p>retina</p>
<blockquote>
<p>Retina display即视网膜屏幕，是苹果发布iPhone 4时候提出的，之所以叫做视网膜屏幕，是因为屏幕的PPI太高，人的视网膜无法分辨出屏幕上的像素点。iPhone 4/S的PPI为326，是iPhone 3G/S的两倍。由于屏幕在宽和高的像素数量提高了整整一倍，所以之前非Retina屏幕上的一个像素渲染的内容在Retina屏幕上会用4个像素去渲染：1x1 px(non Retina) = 2x2 px(Retina)，这样元素的内容就会变得精细。注意，Retina display是苹果注册的命名方式，其他厂商只能使用HI-DPI或者其他的命名方式，不过意思都是一样的，就是屏幕的PPI非常高。</p>
</blockquote>
</li>
</ul>
<p>下面着重区分两个pt的概念</p>
<ul>
<li><p>pt(iOS中的逻辑像素)</p>
<blockquote>
<p>iOS的逻辑像素，或逻辑点，logic point，单位pt。iOS 的 pt 主要用来映射到屏幕，目前 1 point 可能映射到 1/2x2/3x3 pixel，称为 scale，在 iPhone 6 P上由于物理分辨率略微不足实际映射时还有一个 down-sampling。屏幕的scale由系统决定，输出到位图时则可以由程序决定。计算可以得出1pt = 1/163 inch</p>
</blockquote>
</li>
<li><p>pt(打印中使用的长度单位)</p>
<blockquote>
<p>全称「point」，中译「点」（Microsoft Office 里译为「磅」）。这是一个物理单位，它描述的是一段实际的长度，常用于字体排印（typography）与平面设计，比如设定字号和行高。今天的通用标准是 1 pt = 1/72 inch（1 inch = 2.54 cm），这个标准又称「PostScript point」。我们使用 point 时就是希望直接控制输出图形的实际大小（一般是通过印刷）。Point 和厘米、毫米什么的单位没有本质区别，只是长度不同。</p>
</blockquote>
</li>
</ul>
<p>两者是同一个概念，但是不等价。都是逻辑单位，用来隔离输出设备的精度差异，保证输出结果的物理尺寸不会忽大忽小。iOS 的 pt 主要用来映射到屏幕，目前 1 point 可能映射到 1/2x2/3x3 pixel，称为 scale，在 iPhone 6 P上由于物理分辨率略微不足实际映射时还有一个 down-sampling。屏幕的scale由系统决定，输出到位图时则可以由程序决定。PS 的 pt 主要用来映射印刷设备，1 pt 印出来就是 1/72 inch。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到文章开头，其实我们把px除以2的猜想是对的，因为一般的视觉图给的尺寸都是750x1334的，即是按照4.7寸（@2x）设计的，此时1pt=2px。而这与PS设置文稿中的PPI是没有什么关系的。但是当视觉稿中的字体是使用pt为单位时，我们就要注意，若此时是为@2x设计的，则PPI设置为144为佳，因为这样iOS中的pt就可以和PS中的pt相对应，都为2px。而如果是为非retina屏幕设计的，则PPI应设为72，这样两个pt就都等于px了。当然，一般PSD的PPI可以随意设定，是因为我们平时设定字体时也是用px为单位，与PPI无关。且调节PPI只是调节了英寸的大小，但最后需要的是含像素的设计图，而不是多少英寸的图。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.zhihu.com/question/19851058" target="_blank" rel="external">1 pt 的图形大小与其在屏幕上显示出的大小之间有什么关系</a><br><a href="http://www.cnblogs.com/yif1991/p/5236170.html" target="_blank" rel="external">iOS开发中关于像素的几个概念</a><br><a href="http://www.zcool.com.cn/article/ZNDA1ODcy.html" target="_blank" rel="external">关于 iOS 中 pt 的误解</a><br><a href="https://www.zhihu.com/question/21037221" target="_blank" rel="external">UI 设计师提供 iOS 字体和长度应当用什么单位？</a><br><a href="http://www.jianshu.com/p/03d8f48c8903" target="_blank" rel="external">不知道逻辑像素你还是一个合格的iOSUI设计师吗</a><br><a href="http://www.jianshu.com/p/1548e4bdf7e7" target="_blank" rel="external">iOS 四种iPhone屏幕适配方案(借鉴)</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[property,synthesize,dynamic学习笔记]]></title>
      <url>http://lizhan.me/2016/08/06/property,synthesize,dynamic%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="property"><a href="#property" class="headerlink" title="property"></a>property</h1><p>property的作用是声明属性的setter方法和getter方法，并且在一般情况下Xcode可自动合成setter方法和getter方法以及实例变量，效果如下所示：<br> <a id="more"></a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synthesize</span> var = _var;</span><br></pre></td></tr></table></figure></p>
<p>property一般有如下修饰符：</p>
<h2 id="读写修饰符-readwrite-readonly"><a href="#读写修饰符-readwrite-readonly" class="headerlink" title="读写修饰符:  readwrite  |  readonly"></a>读写修饰符:  readwrite  |  readonly</h2><ul>
<li>readonly<br>readonly只生成getter方法，并且在其他文件中无法使用getter方法修改属性对应的实例变量的值。但可通过一些措施在.m文件中修改它的值。并且可以通过声明其他的一些方法在其他文件中来改变readonly修饰的属性对应的实例变量的值，但这并不符合面向对象的封装原则，所以并不推荐。</li>
<li>readwrite<br>readwrite既会合成getter方法也会生成setter方法，是默认修饰符。</li>
</ul>
<h2 id="setter相关修饰符-assign-retain-copy-strong-weak"><a href="#setter相关修饰符-assign-retain-copy-strong-weak" class="headerlink" title="setter相关修饰符:  assign  |  retain  |  copy  |  strong  |  weak"></a>setter相关修饰符:  assign  |  retain  |  copy  |  strong  |  weak</h2><ul>
<li>assign<br>非对象的数据类型默认使用assign修饰。若用来修饰对象，对象的计数器不会+1。而且当对象销毁后，指针不会指向nil，会出现野指针。</li>
<li>retain<br>在MRC中retain默认修饰对象。</li>
<li><p>copy<br>对于setter方法它是这样实现的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>) setVar:(ObjectType *) theVar&#123;</span><br><span class="line"><span class="keyword">if</span> (theVar != var)</span><br><span class="line">var = [theVar <span class="keyword">copy</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strong<br>通常，所有对象的指针变量都是强变量。对象的引用赋值给strong修饰的属性时，该对象将会自动保持(新对象计数器+1)，但是旧对象的引用会在赋值前被释放（旧对象计数器-1）。<br>对于setter方法它是这样实现的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>) setVar:(<span class="built_in">NSString</span> *) theVar&#123;</span><br><span class="line">[theVar retian]; <span class="comment">//theVar指向的对象计数器+1</span></span><br><span class="line">[var release];  <span class="comment">//var指向的对象计数器-1</span></span><br><span class="line">var = theVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>weak<br>weak 修饰的引用计数器不会+1。<br>为了防止两个强变量间的循环引用导致retain cycle可以使用weak。<br>当它所指向的对象被销毁时，指向nil。</p>
</li>
</ul>
<p>值得注意的是，对象的属性默认不是strong，而是unsafe_unretained(相当于assign)。</p>
<p>PS：关于这部分的说明有点混乱，因为对于objc的内存管理机制还是云里雾里，而且被变量和属性以及ARC和MRC绕的有点晕。我想在之后专门学习一下内存管理机制。</p>
<h2 id="原子性修饰符-atomic-nonatomic"><a href="#原子性修饰符-atomic-nonatomic" class="headerlink" title="原子性修饰符:  atomic  |  nonatomic"></a>原子性修饰符:  atomic  |  nonatomic</h2><ul>
<li>atomic<br>atomic可以对生成的setter方法加互斥锁，以此保证同一时间只有一个线程调用setter方法 。然而如果不同线程同时调用setter和getter方法时还是会出现问题。所以即使用了atomic修饰也不一定是线程安全的。</li>
<li>nonatomic<br>与atomic相比较， nonatomic不能对生成的 setter方法加互斥锁， 但是相比较atomic来说，性能要好许多，因为atomic需要耗费许多系统资源。</li>
</ul>
<p>属性默认是atomic的。</p>
<h1 id="synthesize"><a href="#synthesize" class="headerlink" title="synthesize"></a>synthesize</h1><p>sysnthesize的作用是合成setter方法（若属性被readonly修饰则不会生成）以及getter方法，并且声明一个与属性同名的实例变量。</p>
<h1 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h1><p>@dynamic告诉编译器,属性的setter与getter方法由用户自己实现，不自动合成。假如一个属性被声明为@dynamic var，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行setter或getter方法时，会导致程序崩溃。</p>
<h1 id="关于property的一些问题"><a href="#关于property的一些问题" class="headerlink" title="关于property的一些问题"></a>关于property的一些问题</h1><p>在一些情况下property可能不会自动生成setter和getter方法。如出现</p>
<blockquote>
<p>Auto property synthesis will not synthesize property ‘via’ because it is  ‘readwrite’ but it will be synthesized ‘readonly’ via another property</p>
</blockquote>
<p>的警告,这是因为声明property时将继承的readonly属性重新声明为readwrite属性, 导致自动合成时发生冲突，针对这种情况有以下几种解决方法：</p>
<ol>
<li>可以自己在implement中添加@synthesize。</li>
<li><p>如果能访问superclass.m文件的话，也可以通过extension在.m文件中加入</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> ObjectType *var;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或自己手动实现setter方法。这样就可以在父类中将setter和getter方法同时生成, 然后在子类中通过@dynamic(其实也可以不用，只是用来消除警告)来使用父类中的setter和getter方法。</p>
</li>
</ol>
<p>通过这个问题的研究，我们也就知道如何在.m文件中修改对应readonly属性的实例变量值的办法。如使用extension或自己手动生成setter方法。</p>
<p>还有一个问题就是如果没有生成setter方法，却在setter方法的实现中使用<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setVar:(ObjectType *)theVar&#123;</span><br><span class="line"><span class="keyword">self</span>.var = theVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将会导致死循环。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习，对之前一些模糊的概念有了深刻的认识。在学习中也接触到了一些关于objc内存管理的机制，感觉自己对于这方面的知识还是很不了解，仍需更加深入的学习。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发中页面间传值方法总结]]></title>
      <url>http://lizhan.me/2016/06/23/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E9%A1%B5%E9%9D%A2%E9%97%B4%E4%BC%A0%E5%80%BC%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="iOS页面间传值的方法"><a href="#iOS页面间传值的方法" class="headerlink" title="iOS页面间传值的方法"></a>iOS页面间传值的方法</h1><p>在iOS中页面间传值一般有以下几种方法:</p>
<ol>
<li>属性传值</li>
<li>代理传值</li>
<li>blcok传值</li>
<li>NSNotification</li>
<li>NSUserDefaults</li>
<li>单例传值</li>
</ol>
<p>可能还有一些其他的方法,这里不再进行详细介绍。这六种方式各有特点，不同的情况下可使用不同的方式，下面我们来看下详细的使用方法。<br> <a id="more"></a></p>
<h2 id="一-属性传值"><a href="#一-属性传值" class="headerlink" title="一. 属性传值"></a>一. 属性传值</h2><p>属性传值一般适用于将值从前一视图向后一视图传递。而属性传值的代码也非常简单，先在第二个视图类中声明一个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">interface SecondViewController : UIViewController</span><br><span class="line">property NSString *string;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>然后在第一个视图的实现类中进行传值操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)passData&#123;</span><br><span class="line">SecondViewController *secondVC = [[SecondViewController alloc]init];</span><br><span class="line">secondVC.string = self.textField.text;</span><br><span class="line">[self.navigationController pushViewController:second animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二-代理传值"><a href="#二-代理传值" class="headerlink" title="二. 代理传值"></a>二. 代理传值</h2><p>代理模式是一种简单的设计模式，在iOS开发中可通过协议来实现<br>使用代理既可以用于正向也可以用于反向传值，下面以反向传值为例。<br>首先在第二个页面的类中声明协议，以及一个id类型的delegate属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@protocol backProtocol &lt;NSObject&gt;</span><br><span class="line">-(void) backPass:(NSString *)string;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface SecondViewController : UIViewController</span><br><span class="line">@property id &lt;backProtocol&gt; delegate;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>之后在实现文件中调用代理方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ([self.delegate respondsToSelector:@selector(backPass:)])</span><br><span class="line">&#123;</span><br><span class="line">[self.delegate backPass:self.textField.text];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后在第一个页面中声明遵守这一协议，并将自己设为代理，然后实现这一协议中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secondVC.delegate = self;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)backPass:(NSString *)string&#123;</span><br><span class="line">self.textField.text = string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样简单的代理就完成了，它实现了将第二个页面中textField的值传入第一个页面的textField中。如果想更深入的了解代理模式，请<a href="http://www.cocoachina.com/ios/20160317/15696.html" target="_blank" rel="external">戳这里</a></p>
<h2 id="三-block传值"><a href="#三-block传值" class="headerlink" title="三. block传值"></a>三. block传值</h2><p>block本质上和其他变量类似，只不过block中存储的数据是一个函数体，你可以把它想象成是一个指向函数的指针，但其实这两者也有许多不同。如果想深入了解block语法的内容，可以看下<a href="http://www.devtalking.com/articles/you-should-know-block/" target="_blank" rel="external">这篇文章</a>。<br>现在介绍简单的反向传值。首先在第二个类中声明block属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">typedef void(^passValueBlock)(NSString *blockString);</span><br><span class="line">@interface SecondViewController : UIViewController</span><br><span class="line">@property(nonatomic,copy) passValueBlock block;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>然后在实现文件中传值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.block(self.textField.text);</span><br></pre></td></tr></table></figure></p>
<p>最后在第一个页面中实现block方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secondVC.block = ^(NSString *string)&#123;</span><br><span class="line">self.textField.text = string;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样就实现了将第二个页面的textField的值传入第一个页面的textField中。</p>
<h2 id="四-NSNotification传值"><a href="#四-NSNotification传值" class="headerlink" title="四. NSNotification传值"></a>四. NSNotification传值</h2><p>NSNotification其实就是在iOS中对观察者模式的一种实现。而通过NSNotification传值则非常简单。<br>首先就是在需要传值的类中发送通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter]postNotificationName:@&quot;passData&quot; object:self.textField.text];</span><br></pre></td></tr></table></figure></p>
<p>然后在其他类中添加观察者并实现方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(passData:) name:@&quot;passData&quot; object:nil];</span><br><span class="line"></span><br><span class="line">-(void)passData:(NSNotification *)data&#123;</span><br><span class="line">self.textField.text = data.object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后不要忘了在dealloc方法中撤销通知中心，以免资源的浪费<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)dealloc&#123;</span><br><span class="line">[[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="五-NSUserDefaults"><a href="#五-NSUserDefaults" class="headerlink" title="五. NSUserDefaults"></a>五. NSUserDefaults</h2><p>NSUserDefaults在iOS开发中主要用于存储轻量数据，用于数据持久化。但是也可以用它进行页面间的传值<br>首先在一个界面中进行存储操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">[defaults setObject:self.textField.text forKey:@&quot;string&quot;];</span><br></pre></td></tr></table></figure></p>
<p>然后在另一个页面中进行读取操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">self.textField.text = [defaults objectForKey:@&quot;string&quot;];</span><br></pre></td></tr></table></figure></p>
<p>关于NSUserDefaults的更多内容，请点击<a href="http://www.jianshu.com/p/459c15cf6ce2" target="_blank" rel="external">这里</a></p>
<h2 id="六-单例传值"><a href="#六-单例传值" class="headerlink" title="六. 单例传值"></a>六. 单例传值</h2><p>首先新建一个单例类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface DataManager : NSObject</span><br><span class="line">+(instancetype)Default;</span><br><span class="line">@property(nonatomic,strong) NSString *string;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;DataManager.h&quot;</span><br><span class="line">static DataManager *manger = nil;</span><br><span class="line">@implementation DataManager</span><br><span class="line">+(instancetype)Default&#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken,^&#123;</span><br><span class="line">manger = [[DataManager alloc]init];</span><br><span class="line">&#125;);</span><br><span class="line">return manger;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后便可通过属性string进行传值<br>先在一个页面中将值传入单例manager中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataManager *manager = [DataManager Default];</span><br><span class="line">manager.string = self.textField.text;</span><br></pre></td></tr></table></figure></p>
<p>再在另一个页面通过它传给其他对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataManager *manager = [DataManager Default];</span><br><span class="line">self.textField.text = manager.string;</span><br></pre></td></tr></table></figure></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><del>真是越到期末我越浪。在期末考前还在写博客，也真是作死呀。</del> 不过通过这第一次写技术博客的经历，感觉对知识又有了更深入的理解，并且能把自己的笔记分享出来，感觉也是非常的棒。当然笔记中难免有许多错误，也烦请读者不吝指出。最后，要赶紧滚去复习了，逃~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[纪念第一次博客搭建]]></title>
      <url>http://lizhan.me/2016/06/09/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>折腾了一天，总算把博客搭建完成了。希望以后能在这多写点东西，记录下自己的成长历程<br>。也希望我的分享可以带给大家一些有用的东西。<br> <a id="more"></a><br>谨以此文纪念在异乡的第一个端午。</p>
]]></content>
    </entry>
    
  
  
</search>
