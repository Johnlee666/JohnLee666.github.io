<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[iOS中的pt和px]]></title>
      <url>http://yoursite.com/2017/08/09/iOS%E4%B8%AD%E7%9A%84pt%E5%92%8Cpx/</url>
      <content type="html"><![CDATA[<h1 id="iOS关于px和pt的一些问题"><a href="#iOS关于px和pt的一些问题" class="headerlink" title="iOS关于px和pt的一些问题"></a>iOS关于px和pt的一些问题</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近在还原psd设计图的时候遇到一些问题，就是设计图上给的距离都是px而在iOS开发中却可能用到pt这个单位。那这两者的换算关系是什么呢。之前的话直接都是把视觉稿的px除以2当pt来用，也没有深究为什么。这几天想深入了解一下，但是网上资料鱼龙混杂，一些错误的概念充斥其间，所以想写篇文章来好好理一理其中的一些关系。这之前需要先解释几个概念:</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>DPI</p>
<blockquote>
<p>DPI (Dots Per Inch) Dot 指的是采样或输出的最小单位，它很抽象，在不同的设备里会和不同的具体事物关联起来。比如：扫描仪的 Dot 就是它能扫描（采样）出的最小一点色彩信息，这些采样点集合起来然后转换为对应的像素，一般不是一对一的；打印机的 Dot 就是它能印出的最小墨点，需要许多个墨点组合起来才能表现出数字图片中的一个（虚拟的）像素；而有时我们用 DPI 来描述显示器时，Dot 就是显示器的逻辑像素，如iPhone中的pt (point)。</p>
</blockquote>
</li>
<li><p>PPI</p>
<blockquote>
<p>计算机显示设备从打印机中借鉴了DPI的概念，由于计算机显示设备中的原子单位不是墨汁点而是像素，所以就创造了PPI(Pixels Per Inch)，这个值是屏幕每英寸的像素数量，即像素密度(Screen density)。这里的像素一般指的是物理像素(Physical Pixel)。我们一般将屏幕对角线的物理长度与对角线上的像素数的比值作为PPI的近似值。在屏幕尺寸固定的情况下，PPI越高越清晰（如后面所说的retina屏幕）</p>
</blockquote>
</li>
<li><p>px</p>
<blockquote>
<p>px是Pixel的缩写，也就是说像素是指基本原色素及其灰度的基本编码，由 Picture(图像) 和 Element（元素）这两个单词的字母所组成的。我们平时常说的分辨率就是由宽高像素个数相乘得到。但仅凭这一分辨率并不能判断屏幕清晰程度，还要与屏幕尺寸相联系。</p>
</blockquote>
</li>
<li><p>retina</p>
<blockquote>
<p>Retina display即视网膜屏幕，是苹果发布iPhone 4时候提出的，之所以叫做视网膜屏幕，是因为屏幕的PPI太高，人的视网膜无法分辨出屏幕上的像素点。iPhone 4/S的PPI为326，是iPhone 3G/S的两倍。由于屏幕在宽和高的像素数量提高了整整一倍，所以之前非Retina屏幕上的一个像素渲染的内容在Retina屏幕上会用4个像素去渲染：1x1 px(non Retina) = 2x2 px(Retina)，这样元素的内容就会变得精细。注意，Retina display是苹果注册的命名方式，其他厂商只能使用HI-DPI或者其他的命名方式，不过意思都是一样的，就是屏幕的PPI非常高。</p>
</blockquote>
</li>
</ul>
<p>下面着重区分两个pt的概念</p>
<ul>
<li><p>pt(iOS中的逻辑像素)</p>
<blockquote>
<p>iOS的逻辑像素，或逻辑点，logic point，单位pt。iOS 的 pt 主要用来映射到屏幕，目前 1 point 可能映射到 1/2x2/3x3 pixel，称为 scale，在 iPhone 6 P上由于物理分辨率略微不足实际映射时还有一个 down-sampling。屏幕的scale由系统决定，输出到位图时则可以由程序决定。计算可以得出1pt = 1/163 inch</p>
</blockquote>
</li>
<li><p>pt(打印中使用的长度单位)</p>
<blockquote>
<p>全称「point」，中译「点」（Microsoft Office 里译为「磅」）。这是一个物理单位，它描述的是一段实际的长度，常用于字体排印（typography）与平面设计，比如设定字号和行高。今天的通用标准是 1 pt = 1/72 inch（1 inch = 2.54 cm），这个标准又称「PostScript point」。我们使用 point 时就是希望直接控制输出图形的实际大小（一般是通过印刷）。Point 和厘米、毫米什么的单位没有本质区别，只是长度不同。</p>
</blockquote>
</li>
</ul>
<p>两者是同一个概念，但是不等价。都是逻辑单位，用来隔离输出设备的精度差异，保证输出结果的物理尺寸不会忽大忽小。iOS 的 pt 主要用来映射到屏幕，目前 1 point 可能映射到 1/2x2/3x3 pixel，称为 scale，在 iPhone 6 P上由于物理分辨率略微不足实际映射时还有一个 down-sampling。屏幕的scale由系统决定，输出到位图时则可以由程序决定。PS 的 pt 主要用来映射印刷设备，1 pt 印出来就是 1/72 inch。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到文章开头，其实我们把px除以2的猜想是对的，因为一般的视觉图给的尺寸都是750x1334的，即是按照4.7寸（@2x）设计的，此时1pt=2px。而这与PS设置文稿中的PPI是没有什么关系的。但是当视觉稿中的字体是使用pt为单位时，我们就要注意，若此时是为@2x设计的，则PPI设置为144为佳，因为这样iOS中的pt就可以和PS中的pt相对应，都为2px。而如果是为非retina屏幕设计的，则PPI应设为72，这样两个pt就都等于px了。当然，一般PSD的PPI可以随意设定，是因为我们平时设定字体时也是用px为单位，与PPI无关。且调节PPI只是调节了英寸的大小，但最后需要的是含像素的设计图，而不是多少英寸的图。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.zhihu.com/question/19851058" target="_blank" rel="external">1 pt 的图形大小与其在屏幕上显示出的大小之间有什么关系</a><br><a href="http://www.cnblogs.com/yif1991/p/5236170.html" target="_blank" rel="external">iOS开发中关于像素的几个概念</a><br><a href="http://www.zcool.com.cn/article/ZNDA1ODcy.html" target="_blank" rel="external">关于 iOS 中 pt 的误解</a><br><a href="https://www.zhihu.com/question/21037221" target="_blank" rel="external">UI 设计师提供 iOS 字体和长度应当用什么单位？</a><br><a href="http://www.jianshu.com/p/03d8f48c8903" target="_blank" rel="external">不知道逻辑像素你还是一个合格的iOSUI设计师吗</a><br><a href="http://www.jianshu.com/p/1548e4bdf7e7" target="_blank" rel="external">iOS 四种iPhone屏幕适配方案(借鉴)</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[property,synthesize,dynamic学习笔记]]></title>
      <url>http://yoursite.com/2016/08/06/property,synthesize,dynamic%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="property"><a href="#property" class="headerlink" title="property"></a>property</h1><p>property的作用是声明属性的setter方法和getter方法，并且在一般情况下Xcode可自动合成setter方法和getter方法以及实例变量，效果如下所示：<br> <a id="more"></a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synthesize</span> var = _var;</span><br></pre></td></tr></table></figure></p>
<p>property一般有如下修饰符：</p>
<h2 id="读写修饰符-readwrite-readonly"><a href="#读写修饰符-readwrite-readonly" class="headerlink" title="读写修饰符:  readwrite  |  readonly"></a>读写修饰符:  readwrite  |  readonly</h2><ul>
<li>readonly<br>readonly只生成getter方法，并且在其他文件中无法使用getter方法修改属性对应的实例变量的值。但可通过一些措施在.m文件中修改它的值。并且可以通过声明其他的一些方法在其他文件中来改变readonly修饰的属性对应的实例变量的值，但这并不符合面向对象的封装原则，所以并不推荐。</li>
<li>readwrite<br>readwrite既会合成getter方法也会生成setter方法，是默认修饰符。</li>
</ul>
<h2 id="setter相关修饰符-assign-retain-copy-strong-weak"><a href="#setter相关修饰符-assign-retain-copy-strong-weak" class="headerlink" title="setter相关修饰符:  assign  |  retain  |  copy  |  strong  |  weak"></a>setter相关修饰符:  assign  |  retain  |  copy  |  strong  |  weak</h2><ul>
<li>assign<br>非对象的数据类型默认使用assign修饰。若用来修饰对象，对象的计数器不会+1。而且当对象销毁后，指针不会指向nil，会出现野指针。</li>
<li>retain<br>在MRC中retain默认修饰对象。</li>
<li><p>copy<br>对于setter方法它是这样实现的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>) setVar:(ObjectType *) theVar&#123;</span><br><span class="line"><span class="keyword">if</span> (theVar != var)</span><br><span class="line">var = [theVar <span class="keyword">copy</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strong<br>通常，所有对象的指针变量都是强变量。对象的引用赋值给strong修饰的属性时，该对象将会自动保持(新对象计数器+1)，但是旧对象的引用会在赋值前被释放（旧对象计数器-1）。<br>对于setter方法它是这样实现的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>) setVar:(<span class="built_in">NSString</span> *) theVar&#123;</span><br><span class="line">[theVar retian]; <span class="comment">//theVar指向的对象计数器+1</span></span><br><span class="line">[var release];  <span class="comment">//var指向的对象计数器-1</span></span><br><span class="line">var = theVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>weak<br>weak 修饰的引用计数器不会+1。<br>为了防止两个强变量间的循环引用导致retain cycle可以使用weak。<br>当它所指向的对象被销毁时，指向nil。</p>
</li>
</ul>
<p>值得注意的是，对象的属性默认不是strong，而是unsafe_unretained(相当于assign)。</p>
<p>PS：关于这部分的说明有点混乱，因为对于objc的内存管理机制还是云里雾里，而且被变量和属性以及ARC和MRC绕的有点晕。我想在之后专门学习一下内存管理机制。</p>
<h2 id="原子性修饰符-atomic-nonatomic"><a href="#原子性修饰符-atomic-nonatomic" class="headerlink" title="原子性修饰符:  atomic  |  nonatomic"></a>原子性修饰符:  atomic  |  nonatomic</h2><ul>
<li>atomic<br>atomic可以对生成的setter方法加互斥锁，以此保证同一时间只有一个线程调用setter方法 。然而如果不同线程同时调用setter和getter方法时还是会出现问题。所以即使用了atomic修饰也不一定是线程安全的。</li>
<li>nonatomic<br>与atomic相比较， nonatomic不能对生成的 setter方法加互斥锁， 但是相比较atomic来说，性能要好许多，因为atomic需要耗费许多系统资源。</li>
</ul>
<p>属性默认是atomic的。</p>
<h1 id="synthesize"><a href="#synthesize" class="headerlink" title="synthesize"></a>synthesize</h1><p>sysnthesize的作用是合成setter方法（若属性被readonly修饰则不会生成）以及getter方法，并且声明一个与属性同名的实例变量。</p>
<h1 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h1><p>@dynamic告诉编译器,属性的setter与getter方法由用户自己实现，不自动合成。假如一个属性被声明为@dynamic var，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行setter或getter方法时，会导致程序崩溃。</p>
<h1 id="关于property的一些问题"><a href="#关于property的一些问题" class="headerlink" title="关于property的一些问题"></a>关于property的一些问题</h1><p>在一些情况下property可能不会自动生成setter和getter方法。如出现</p>
<blockquote>
<p>Auto property synthesis will not synthesize property ‘via’ because it is  ‘readwrite’ but it will be synthesized ‘readonly’ via another property</p>
</blockquote>
<p>的警告,这是因为声明property时将继承的readonly属性重新声明为readwrite属性, 导致自动合成时发生冲突，针对这种情况有以下几种解决方法：</p>
<ol>
<li>可以自己在implement中添加@synthesize。</li>
<li><p>如果能访问superclass.m文件的话，也可以通过extension在.m文件中加入</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> ObjectType *var;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或自己手动实现setter方法。这样就可以在父类中将setter和getter方法同时生成, 然后在子类中通过@dynamic(其实也可以不用，只是用来消除警告)来使用父类中的setter和getter方法。</p>
</li>
</ol>
<p>通过这个问题的研究，我们也就知道如何在.m文件中修改对应readonly属性的实例变量值的办法。如使用extension或自己手动生成setter方法。</p>
<p>还有一个问题就是如果没有生成setter方法，却在setter方法的实现中使用<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setVar:(ObjectType *)theVar&#123;</span><br><span class="line"><span class="keyword">self</span>.var = theVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将会导致死循环。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习，对之前一些模糊的概念有了深刻的认识。在学习中也接触到了一些关于objc内存管理的机制，感觉自己对于这方面的知识还是很不了解，仍需更加深入的学习。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发中页面间传值方法总结]]></title>
      <url>http://yoursite.com/2016/06/23/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E9%A1%B5%E9%9D%A2%E9%97%B4%E4%BC%A0%E5%80%BC%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="iOS页面间传值的方法"><a href="#iOS页面间传值的方法" class="headerlink" title="iOS页面间传值的方法"></a>iOS页面间传值的方法</h1><p>在iOS中页面间传值一般有以下几种方法:</p>
<ol>
<li>属性传值</li>
<li>代理传值</li>
<li>blcok传值</li>
<li>NSNotification</li>
<li>NSUserDefaults</li>
<li>单例传值</li>
</ol>
<p>可能还有一些其他的方法,这里不再进行详细介绍。这六种方式各有特点，不同的情况下可使用不同的方式，下面我们来看下详细的使用方法。<br> <a id="more"></a></p>
<h2 id="一-属性传值"><a href="#一-属性传值" class="headerlink" title="一. 属性传值"></a>一. 属性传值</h2><p>属性传值一般适用于将值从前一视图向后一视图传递。而属性传值的代码也非常简单，先在第二个视图类中声明一个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">interface SecondViewController : UIViewController</span><br><span class="line">property NSString *string;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>然后在第一个视图的实现类中进行传值操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)passData&#123;</span><br><span class="line">SecondViewController *secondVC = [[SecondViewController alloc]init];</span><br><span class="line">secondVC.string = self.textField.text;</span><br><span class="line">[self.navigationController pushViewController:second animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二-代理传值"><a href="#二-代理传值" class="headerlink" title="二. 代理传值"></a>二. 代理传值</h2><p>代理模式是一种简单的设计模式，在iOS开发中可通过协议来实现<br>使用代理既可以用于正向也可以用于反向传值，下面以反向传值为例。<br>首先在第二个页面的类中声明协议，以及一个id类型的delegate属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@protocol backProtocol &lt;NSObject&gt;</span><br><span class="line">-(void) backPass:(NSString *)string;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface SecondViewController : UIViewController</span><br><span class="line">@property id &lt;backProtocol&gt; delegate;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>之后在实现文件中调用代理方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ([self.delegate respondsToSelector:@selector(backPass:)])</span><br><span class="line">&#123;</span><br><span class="line">[self.delegate backPass:self.textField.text];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后在第一个页面中声明遵守这一协议，并将自己设为代理，然后实现这一协议中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secondVC.delegate = self;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)backPass:(NSString *)string&#123;</span><br><span class="line">self.textField.text = string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样简单的代理就完成了，它实现了将第二个页面中textField的值传入第一个页面的textField中。如果想更深入的了解代理模式，请<a href="http://www.cocoachina.com/ios/20160317/15696.html" target="_blank" rel="external">戳这里</a></p>
<h2 id="三-block传值"><a href="#三-block传值" class="headerlink" title="三. block传值"></a>三. block传值</h2><p>block本质上和其他变量类似，只不过block中存储的数据是一个函数体，你可以把它想象成是一个指向函数的指针，但其实这两者也有许多不同。如果想深入了解block语法的内容，可以看下<a href="http://www.devtalking.com/articles/you-should-know-block/" target="_blank" rel="external">这篇文章</a>。<br>现在介绍简单的反向传值。首先在第二个类中声明block属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">typedef void(^passValueBlock)(NSString *blockString);</span><br><span class="line">@interface SecondViewController : UIViewController</span><br><span class="line">@property(nonatomic,copy) passValueBlock block;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>然后在实现文件中传值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.block(self.textField.text);</span><br></pre></td></tr></table></figure></p>
<p>最后在第一个页面中实现block方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secondVC.block = ^(NSString *string)&#123;</span><br><span class="line">self.textField.text = string;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样就实现了将第二个页面的textField的值传入第一个页面的textField中。</p>
<h2 id="四-NSNotification传值"><a href="#四-NSNotification传值" class="headerlink" title="四. NSNotification传值"></a>四. NSNotification传值</h2><p>NSNotification其实就是在iOS中对观察者模式的一种实现。而通过NSNotification传值则非常简单。<br>首先就是在需要传值的类中发送通知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter]postNotificationName:@&quot;passData&quot; object:self.textField.text];</span><br></pre></td></tr></table></figure></p>
<p>然后在其他类中添加观察者并实现方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(passData:) name:@&quot;passData&quot; object:nil];</span><br><span class="line"></span><br><span class="line">-(void)passData:(NSNotification *)data&#123;</span><br><span class="line">self.textField.text = data.object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后不要忘了在dealloc方法中撤销通知中心，以免资源的浪费<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)dealloc&#123;</span><br><span class="line">[[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="五-NSUserDefaults"><a href="#五-NSUserDefaults" class="headerlink" title="五. NSUserDefaults"></a>五. NSUserDefaults</h2><p>NSUserDefaults在iOS开发中主要用于存储轻量数据，用于数据持久化。但是也可以用它进行页面间的传值<br>首先在一个界面中进行存储操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">[defaults setObject:self.textField.text forKey:@&quot;string&quot;];</span><br></pre></td></tr></table></figure></p>
<p>然后在另一个页面中进行读取操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">self.textField.text = [defaults objectForKey:@&quot;string&quot;];</span><br></pre></td></tr></table></figure></p>
<p>关于NSUserDefaults的更多内容，请点击<a href="http://www.jianshu.com/p/459c15cf6ce2" target="_blank" rel="external">这里</a></p>
<h2 id="六-单例传值"><a href="#六-单例传值" class="headerlink" title="六. 单例传值"></a>六. 单例传值</h2><p>首先新建一个单例类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface DataManager : NSObject</span><br><span class="line">+(instancetype)Default;</span><br><span class="line">@property(nonatomic,strong) NSString *string;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;DataManager.h&quot;</span><br><span class="line">static DataManager *manger = nil;</span><br><span class="line">@implementation DataManager</span><br><span class="line">+(instancetype)Default&#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken,^&#123;</span><br><span class="line">manger = [[DataManager alloc]init];</span><br><span class="line">&#125;);</span><br><span class="line">return manger;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后便可通过属性string进行传值<br>先在一个页面中将值传入单例manager中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataManager *manager = [DataManager Default];</span><br><span class="line">manager.string = self.textField.text;</span><br></pre></td></tr></table></figure></p>
<p>再在另一个页面通过它传给其他对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataManager *manager = [DataManager Default];</span><br><span class="line">self.textField.text = manager.string;</span><br></pre></td></tr></table></figure></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><del>真是越到期末我越浪。在期末考前还在写博客，也真是作死呀。</del> 不过通过这第一次写技术博客的经历，感觉对知识又有了更深入的理解，并且能把自己的笔记分享出来，感觉也是非常的棒。当然笔记中难免有许多错误，也烦请读者不吝指出。最后，要赶紧滚去复习了，逃~</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[纪念第一次博客搭建]]></title>
      <url>http://yoursite.com/2016/06/09/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>折腾了一天，总算把博客搭建完成了。希望以后能在这多写点东西，记录下自己的成长历程<br>。也希望我的分享可以带给大家一些有用的东西。<br> <a id="more"></a><br>谨以此文纪念在异乡的第一个端午。</p>
]]></content>
    </entry>
    
  
  
</search>
